# 1. Construindo abstrações com procedimentos

> Os atos da mente, em que ela exerce o seu poder sobre as ideias simples, são principalmente estes três: 1. Combinar várias ideias simples em uma só composta, formando assim todas as ideias complexas. 2. O segundo ato é juntar duas ideias, simples ou complexas, e colocá-las lado a lado, de modo a vê-las de uma só vez, sem uni-las em uma só, por meio da qual ela obtém todas as suas idéias de relações. 3. O terceiro é separá-las de todas as outras ideias que as acompanham na sua existência real: a isto chama-se abstração, e assim são feitas todas as ideias gerais de abstração.
> - John Locke, Um Ensaio sobre o Entendimento Humano (1690)


Vamos começar a estudar _processos_ computacionais. Processos computacionais são seres abstratos que vivem nos computadores. Enquanto evoluem, eles mexem com outras coisas abstratas chamadas _dados_. A evolução de um processo é determinada por um conjunto de regras chamado _programa_. As pessoas criam programas para conduzir processos. Na prática, estamos usando nossos feitiços para invocar os espíritos do computador.

Um processo computacional é, de fato, muito parecido com o conceito de um espírito para quem faz feitiçaria. Não podemos ver ou tocar processos computacionais; eles não têm corpo, mas são muito reais. Podem fazer trabalhos intelectuais, responder perguntas e afetar o mundo ao tirar dinheiro do banco ou controlar um braço mecânico em uma fábrica. Os programas que usamos para invocar esses processos são como feitiços: eles são cuidadosamente criados com expressões simbólicas usando _linguagens de programação_ misteriosas e esotéricas que determinam aquilo que nossos processos devem fazer.

Em um computador sem defeitos, um processo computacional executa programas com precisão e exatidão. Assim, tal como aprendizes de feitiçaria, quem está começando a programar tem que aprender a compreender e a antecipar as consequências de seus feitiços. Até os pequenos erros nos programas (normalmente chamados de _bugs_ ou _glitches_) podem ter consequências complexas e imprevistas.

Felizmente, aprender a programar é bem  menos perigoso do que aprender feitiçaria, porque os espíritos com que lidamos estão convenientemente contidos de forma segura. Mas, a programação da vida real requer cuidado, perícia e sabedoria. Um pequeno erro em um programa de design assistido por computador, por exemplo, pode levar ao colapso catastrófico de um avião, de uma barragem ou à auto-destruição de um robô industrial.

Especialistas na engenharia de software conseguem programar garantindo de forma razoável que os processos cumpram as tarefas pretendidas. Essas pessoas conseguem ver antecipadamente o comportamento dos sistemas, sabem estruturar programas para que imprevistos não tenham consequências catastróficas e, quando os problemas aparecem, elas conseguem fazer o _debug_ do programa. Sistemas computacionais bem projetados, assim como carros ou reatores nucleares bem projetados, são planejados em módulos para que as peças sejam construídas, substituídas e _debugged_ separadamente.

## Programação em Lisp

Precisamos de uma linguagem adequada para descrever processos. Para isso, vamos usar a linguagem de programação Lisp. Assim como expressamos nossos pensamentos em nossa própria língua (como o português, o francês ou o japonês) e descrevemos fenômenos quantitativos em notações matemáticas, vamos expressar nossos pensamentos sobre processos em Lisp. O Lisp foi criado no fim dos anos 50 para formalizar o uso de certos tipos de expressões lógicas, chamadas de _equações de recursão_, como modelo para a computação. A linguagem foi criada por John McCarthy e baseia-se em seu artigo "Recursive Functions of Symbolic Expressions and Their Computation by Machine" ([McCarthy 1960](TODO: ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA)).

Apesar de ter sido criada como um formalismo matemático, o Lisp é uma linguagem prática. Um _interpretador_ Lisp é uma máquina que executa processos escritos em Lisp. O primeiro interpretador Lisp foi implementado por McCarthy com a ajuda de colegas e estudantes do Grupo de Inteligência Artificial do Laboratório de Eletrônica do MIT e do Centro de Computação do MIT[^1]. O Lisp, cujo nome é um acrônimo de _LISt Processing_ (processamento de listas), foi idealizado para manipular símbolos a fim de resolver problemas de programação como a diferenciação simbólica e a integração de expressões algébricas. Para isso, ele incluiu novos objetos de dados conhecidos como átomos e listas, o que gerou sua notoriedade dentre outras linguagens da época.

O Lisp não foi fruto de um planejamento coordenado. Em vez disso, ele evoluiu informalmente de forma experimental em resposta às necessidades da comunidade e às considerações pragmáticas de implementação. A evolução informal do Lisp continua ao longo dos anos, e a comunidade Lisp costuma resitir às tentativas de sancionar qualquer definição "oficial" da linguagem. Juntamente com a flexibilidade e a elegância do conceito inicial, esta evolução permitiu que o Lisp, a segunda linguagem mais antiga em uso generalizado atualmente (apenas o Fortran é mais antigo), se adaptasse continuamente para incluir ideias mais modernas sobre o design de programas. Assim, o Lisp se tornou uma família de dialetos que, embora compartilhem da maioria das características originais, podem diferir uns dos outros de forma significativa. O dialeto de Lisp usado neste livro chama-se Scheme[^2].

Devido a seu caráter experimental e sua ênfase na manipulação de símbolos, o Lisp foi inicialmente muito ineficiente para cálculos numéricos, ao menos quando comparado ao Fortran. No entanto, ao longo dos anos foram-se criando compiladores que traduzem programas Lisp para código de máquina que faz cálculos numéricos razoavelmente eficientes. Em aplicações especiais, o Lisp tem sido usado com grande eficácia[^3]. Embora o Lisp ainda não tenha superado sua antiga reputação de ser irremediavelmente ineficiente, ele é atualmente usado em muitas aplicações em que a eficiência não é o foco central. Por exemplo, o Lisp tornou-se uma das linguagens preferidas em linguagens de _shell_ de sistemas operativos e em linguagens de extensão de editores e sistemas de design assistido por computador.

Se o Lisp não é uma linguagem convencional, por que vamos usá-lo como viés em nossa discussão sobre programação? Porque ele possui características únicas que o tornam um excelente meio para estudar importantes construções de programação e estruturas de dados, e pode relacioná-las às características linguísticas de apoio. A característica mais significativa é que as próprias descrições de processos do Lisp, chamadas _procedimentos_, podem ser representadas e manipuladas em forma de dados no Lisp. Isso é importante porque existem técnicas poderosas de design de programas que dependem da capacidade de transcender a distinção tradicional de dados "passivos" e processos "ativos". Como vamos descobrir, a flexibilidade do Lisp em lidar com procedimentos em forma de dados o torna uma das linguagens mais convenientes para explorar essas técnicas. A capacidade de representar procedimentos em forma de dados também torna o Lisp uma excelente linguagem para escrever programas que manipulam outros programas em forma de dados, como interpretadores e compiladores que suportam linguagens de computador. Além disso, é muito divertido programar em Lisp.

## Notas de rodapé

[^1] O _Lisp 1 Programmer’s Manual_ (Manual de Programação do Lisp 1) surgiu em 1960, e o _Lisp 1.5 Programmer’s Manual_ (Manual de Programação do Lisp 1.5) por [McCarthy et al. 1965](ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA) foi publicado em 1962. Os primórdios do Lisp são descritos em [McCarthy 1978](ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA).

[^2] Dois dialetos em que foram escritos a maior parte dos principaos programas de Lisp nos anos 70 foram MacLisp([Moon 1978; Pitman 1983](ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA)), criado pelo Project MAC do MIT, e Interlisp ([Teitelman 1974](ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA)), criado pela empresa Bolt Beranek and Newman Inc. e pelo Xerox Palo Alto Research Center. O Portable Standard Lisp ([Hearn 1969; Griss 1981](ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA)) foi um dialeto concebido para ser portado com facilidade entre diferentes máquinas. O MacLisp teve uma variedade de subdialetos, como Franz Lisp, que foi desenvolvido pela Universidade da Califórnia em Berkley, e Zetalisp ([Moon and Weinreb 1981](ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA)), que foi baseado em um processador especialmente criado pelo Laboratório de Inteligência Artificial do MIT para executar o Lisp com muita eficiência. O dialeto usado neste livro, chamado Scheme ([Steele and Sussman 1975](ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA)), foi inventado em 1975 por Guy Lewis Seteele Jr. e Gerald Jay Sussman do Laboratório de Inteligência Artificial do MIT e mais tarde reimplementado para uso instrutivo no MIT. O Scheme se tornou um padrão IEEE em 1990 ([IEEE 1990](ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA)). O dialeto Common Lisp ([Steele 1982, Steele 1990](ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA)) foi desenvolvido pela comunidade Lisp para combinar características de dialetos mais antigos do Lisp e criar um padrão industrial para o Lisp. O Common Lisp se tornou um padrão ANSI em 1994 ([ANSI 1994](ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA)).

[^3] Uma das aplicações especias foi uma inovação computacional de importância científica: uma integração do movimento do sistema solar que ampliava resultados anteriores em quase duas ordens de grandeza, e demonstrou que a dinâmica do sistemas solar é caótica. Essa computação foi possível devido a novos algoritmos de integração e a um compilador e um computador especialmente criados para esta finalidade, tudo isso implementado com a ajuda de ferramentas de software escritas em Lisp ([Abelson et al. 1992; Sussman and Wisdom 1992](ADICIONAR_QUANDO_A_REFERÊNCIA_FOR_CRIADA)).
